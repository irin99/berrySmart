                <meta charset="utf-8" emacsmode="-*- markdown -*-">
                            **berrySmart: Final Report**
                            **Nikhil Murthy, Gabriella Garcia, Sunny Tran and Irin Ghosh**

Farming accounts for 70% of the world’s water consumption, with many over watering their crops, while one-fifth of the world's population lacks safe drinking water. This issue primarily stems from a lack of understanding of what individual plants require in terms of water, fertilizer, sunlight and pesticides. 

The berrySmart device gives farmers a way to better understand their farm. A variety of sensors are strategically placed across the farm, the values of which are POSTed to a central database. We then create a dashboard for farmers that highlight these sensor values along with recommendations based off of them.

This project uses various sensors (soil moisture, temperature, light, humidity) placed in three high priority areas in the farm. Working as nodes in a WiFi overlayed mesh network, each node communicates the location’s data to a central database. The central databases’ data is then analyzed on a dashboard accessible to farmers.


Market
===============================================================================

Our target market is small-scale family or community owned farms. We focus on a variety of berry crops as they are one of the largest agricultural exports for the Northeastern area. The berrySmart device fulfills the need for agricultural efficiency and data analysis for middle-income, low technology farms.  

Berry farming has a variety environmental requirements. Blueberries require acidic soil (4.8 to 5.2) that must be monitored. Berries are high water and high sunlight crops, requiring an abundant supply of high-quality water delivered at the right rate, time and location. Strawberries are particularly sensitive to overcrowding of soil beds and demand consistent pruning and weeding. The use of extensive data collection and analysis in the berrySmart device will enable farmers to better understand and grow their crops.

System Overview
===============================================================================

Our berrySmart system consists of subsystems including sensor nodes (Section 2.1), an edge node (Section 2.2), database (Section 2.3), dashboard (Section 2.4) and the farmer's laptop, which is  used to view the dashboard. An overview of our system is below:

![Figure [system]: The berrySmart system, which includes sensors that communicate through an overlay mesh network over WiFi, a central database and a dashboard that is presented to the farmer.
](./images/system.png width="600px" border="0")

CHANGE TO NON-WIFI INSTEAD OF WIRED

We will now discuss the various components of berrySmart.

Leaf Nodes
-------------------------------------------------------------------------------

Sensor Nodes
-------------------------------------------------------------------------------

Sensor nodes are made up of an ESP, battery and sensors that measure soil moisture, temperature, humidity and ambient light. They are placed throughout the farm (in our case, three positions), and collect sensor values.

Each sensor node is not connected to the Internet directly; rather, it communicates with other sensor nodes in a mesh network. An edge node (Section 2.2) communicates all information to the central server and database (Section 2.3).

Sensor nodes collect information once a minute, and otherwise sleep to conserve power. The sensor nodes are designed to last long periods of times without being connected to a power source, as fully described in Section 4: Power Management. 

Edge Node
-------------------------------------------------------------------------------

The edge node is one sensor node in the mesh network that has the additional functionality of connecting to a WiFi network, such as a hotspot in the farmer's home. This allows our mesh network to communicate with the outside world, specifically sending information to our database (Section 2.3).

Database
-------------------------------------------------------------------------------
berrySmart utilizes two databases and many Handlers to keep track of sensor information, analytics, recommendations and website info. strawberry.db is the central database for sensor readings. login.db is the database that stores the logins and passwords of each dashboard user, ensuring that the dashboard is personalised for each farmer. 

Various Handlers were created such as all_dataHandler.py for reformatting the data into the appropriate formats, berryHandler_v2 for testing the Wifi mesh network, strawberryHandler.py for performing get and pull requests to the strawberry.db database and loginhandler.py for registering an account and logging in users using the login.db database. Additional handlers were implemented for GET requests for the two types of mean and standard deviation: individual mean per sensor node and overall mean for the whole farm system. The dashboard current weather section implemented handlers that directly contacted the openweathermap api to generate the cloud, humidity, sunrise, sunset, temperature, weather, weather icon and wind data. 

Dashboard
-------------------------------------------------------------------------------

The berrySmart dashboard summarizes sensor data and recommendations visually:

(./images/temp.png width="600px" border="0")
(./images/weather.png width="600px" border="0")
(./images/humid.png width="600px" border="0")
(./images/reccommend.png width="600px" border="0")
(./images/alerts.png width="600px" border="0")

We provide maps of the farm with sensor information overlayed, which allow farmers to easily understand the state of their crops. We include current weather conditions paired with recommendations based off of sensor information, such as whether plants should be watered (depending on the type of crop, weather and soil moisture sensor data).  

System: Implementation
===============================================================================

We will now discuss how we implemented berrySmart's system (as outlined in Section 2). 

Parts List
-------------------------------------------------------------------------------

We used external parts, namely sensors, in addition to the provided parts to create berrySmart:

| Part                            | Item Number            | Description                                             | Amount |
|---------------------------------|------------------------|---------------------------------------------------------|--------|
| Soil Moisture Sensor            | Amazon ASIN:B07H3P1NRM | Monitor the amount of moisture in the soil of the plant | 3      |
| Temperature and Humidity Sensor | Amazon ASIN:B01DKC2GQ0 | Sensors for humidity and temperature                    | 3      |
| Photoresistor                   | N/A (from lab)         | Monitor amount of light received by the plant           | 3      |

In addition, MORE HERE (ESP, BREADBOARD)

Sensor Implementation
-------------------------------------------------------------------------------

We collect sensor information once every 10 minutes.

### Soil Moisture

The soil moisture sensors uses Analog to communicate. We connected the sensor to analog port 14.

We developed a calibration procedure to accurately determine the soil moisture at any given point using the following formula:

$$soil\_moisture = \frac{moisture\_upper}{moisture\_upper - moisture\_lower} - \frac{analogRead(A14)/4096.0}{moisture\_upper - moisture\_lower}$$

where $soil\_moisture$ is the soil moisture, $moisture\_upper$ is the upper limit of the soil moisture, $moisture\_lower$ is the lower limit of the soil moisture and $analogread(A14)$ is the analog voltage reading of the sensor. $moisture\_upper$ and $moisture\_lower$ are determined through our calibration process, where we first measure the sensor in air (when it is dry), and set that to $moisture\_upper$, and then place the sensor in a cup of water, and set that value to $moisture\_lower$.

This calibration process allows $soil\_moisture$ to be 1 when the voltage (analogRead(A14)/4096.0) is at the lower limit ($moisture\_lower$), and 0 when the voltage is equal to $moisture\_upper$. 

### Temperature and Humidity

To measure temperature and humidity, we utilized the DHT library (Resource 1), and connected the sensor to port 19 on the ESP. We create a DHT object, as defined in the DHT library, and use its temperature and humidity fields to update our readings. 

### Photoresistor

We use a photoresistor to measure ambient light. The sensor is connected to Analog port 7, and we subtract its voltage from 1 to get its measured brightness:

$$brightness = 1 - \frac{analogRead(A7)}{4096.0}$$

## State Machine: Sensor Node
Add in graphics
Sleep -> Connecting to Client -> Receiving data from client -> Collecting data -> Connecting to next sensor node -> Sending -> Sleep

## State Machine: Edge Node
Add in graphics
Sleep -> Connecting to client -> Receiving data from client -> Collecting data -> Connecting to server -> Sending to server -> Sleep

## WiFi Protocol

In order to achieve the mesh network overlayed with WiFi, we instantiate WiFi signals which connect between adjacent nodes. These WiFi connections are instantiated every time the device wakes up and is ready to receive data, and it is deinitialized once the device has received the data packet. We store the data in a character array, where subsequent data packets from different ESP devices are separated in the character array by a hashtag (#). 

Leaf nodes do not receive data packets, while sensor nodes and edge nodes do, and they relay the data to the next ESP device. Currently, the connections between nodes are hard-coded. However, future iterations could utilize the GPS location of each ESP to determine an optimal path for the packet to traverse to reach the edge node. The edge node is the sole connection in our mesh which is connected to the internet. All packets will be required to go through the edge node in order to be received by the database. Again, future iterations of this mesh could utilize multiple edge nodes to optimally deliver packets of data.

In addition, the WiFi range of the ESP is approximately $63$ feet.

## Sleeping

For our sleeping implementation, we decided to put the ESP into Deep Sleep. We chose this over Hibernation, because Deep Sleep allowed for us to utilize the RTC memory storage to retain information over time. We used an RTC_DATA_ATTR object to store the packet number of each data packet in order to determine if our mesh network dropped any packets over time. Our current implementation has the ESP sleeping for 10 minutes after sending a data packet. Lengthening the sleeping time will improve battery performance.

## Dashboard: Graphs
There are two types of dynamic graphs on the dashboard: mapped graphs and scatter plots. Plotly is used as a platform to create the graphics due to its clean, minimalist aesthetics and potential to add dynamic features. The data is pulled through a GET Request from our central database and then stripped into the appropriate parameters and formats. Our goal is to have a clean, easy to read visualisation of the data to help farmers see the performance and data of each of their sensor nodes/plots.

Scatter Plots display classic data visualisation to farmers. Each graph contains overlayed subplots of each of the sensor node's readings over time (minutes since reading). The graphs are dynamic, enabling the user to scroll over the plots, zoom in and click on points. Beneath each scatter plot are the averages for each sensor node. We have four scatter plots per parameter tested: temperature, humidity, soil moisture and light.

Mapped Graphs overlay the most recent data points on a Mapbox API generated satellite image of the farmer's farm. The GPS coordinates are generated from the individual coordinates of each sensor node, enabling the farmer to see the exact network formation of the system on real time satellite imagery. The data is visualised as large circles over each sensor node, colored by an autoscaled preset colorscale that will range the colors based on previus readings. For example, if the average temperature is approximately 24 degrees Celsius, 24.1 degrees will be colored white while a temperature of 24.9 degrees will be colored red due to the stark contrast between the values based on the average. In addition, the plotted circles display the actual readings as centered text. We have four mapped graphs per parameter tested: temperature, humidity, soil moisture and light.

A third form of dynamic graph was made: a Filled-Area Animation Scatter plot. These enabled the farmer to press play and watch an animation of the scatter plots over time. Unfortunately, the plots took too long to generate when embedded into the html dashboard and would therefore not load and crash the website. There were four animated scatter plots per parameter tested: temperature, humidity, soil moisture and light.


## Dashboard: HTML
IRIN

## Daily Digest
As an additional feature, we created a Daily Digest for the farmer. In case the user does not check their dashboard on a daily basis, Berry Smart sends an automatic email containing a "Today's Scoop" newsletter displaying the averaged plot health statistics for each parameter. This email pulls the average over all the sensor nodes from our database using a GET request, ensuring that the data is up to date. The email is created by overlaying text and data on a base image created using Canva. This email is then sent automatically using a Python script to all members of the berry-smart@mit.edu mailing list.

## Analytics
For the dashboard's Statistics, Recommendations and Alerts sections, we implemented analytics to provide data-based suggestions for the farmer. We calculated the mean and standard deviation for each of the sensor nodes as well as the mean and standard deviation for all of the sensor nodes together using imported numpy and statistics. In this iteration of the product, we pre-set recommended values for each of the parameters based on the optimal conditions for strawberry farming. So the optimal temperature is between 60 degrees and 80 degrees Fahrenheit with direct sunlight as an optimal state. In the future, we intend to allow the farmer to designate which crops they are growing in each plot and then pull the optimal conditions for each crop from our database. Based on these recommended values, the Alerts section displays low/high level alerts based on each sensor node's averaged readings. If the light level in sensor node 2 is on average about 0.1, the alerts section will display "Low light levels in area(s) 2".

Based on the appearance of alerts, suggestions are displayed for the user. In a future iteration, these recommendations will be crop specific. Currently the possible suggestions include:

Low Soil Moisture: "Your plots aren't getting enough water, please water plants in area(s) xxx."

Low Light : "Your plots aren't getting enough light, please remove items that are causing shade or install additional light sources such as lamps in area(s) xxx."

Low / High Humidity: “Your area does not have the appropriate humidity for your plots,  slow down ventilation rates and adjust watering to accommodate humidity in area(s) xxx."

Low / High Temperature: "Your area does not have the appropriate temperature for your plots, consider changing your heating system in area(s) xxx."


## Code: Functions and Classes
ALLLLLLLL


<!--
- state machines (for sensor node, edge node)
- WiFi
- Sleeping
- website: graphs/maps
- website: html
- daily digest
- code (functions/class/file and website code)
- change sensor collection frequency from once per minute to once per twenty minutes>
-->

Demo
===============================================================================

Put video link here, along with pictures

Design Challenges
===============================================================================

- bluetooth (go into detail) NIKHIL/SUNNY
One challenge we encountered early on involved finding the proper documentation about bluetooth. The BLE module of the ESP had very little documentation online, which was one of the main reasons for why we were not able to get the mesh working over bluetooth. We noticed that bluetooth was very unreliable, dropping upwards of $75%$ of our data packets. After realizing that bluetooth was not designed for effective mesh networks, we decided to move to WiFi for our mesh implementation. 

<!--
Lack of documentation is a HUGE factor into why we were not able to do it; led to slow progress.
What even are they keys that we needed for the bluetooth?
That is all I remember. -Sunny
-->


- graphing (maps, dynamic graphs) GABY

Power Management
===============================================================================

From the ESP32 datasheet, we found that the ESP32 uses:

- 120mA in Active Mode
- 10μA in Deep Sleep Mode

Our current implementation keeps the ESP32 in Active Mode for each packet of data to be received and relayed to the next node, which takes approximately 10 seconds. Afterwards, the ESP32 is put into a Deep Sleep Mode for 10 minutes before waking again to take sensor readings.

We approximate that the ESP32 will consume 1.977 mA on average, by being in Active Mode for 10 seconds and Deep Sleep mode for 10 minutes (600 seconds). With a battery size of 1500 mAh, this device has a projected lifespan of 758.73 hours, or 31.61 days. We can extend the lifespan by decreasing the sampling rate of the device.


Conclusion
===============================================================================

berrySmart utilizes a WiFi overlayed mesh network to communicate sensor values specific to agriculture to a central server, which then presents the information visually in the form of a dashboard.

Contact Us
===============================================================================
We would love to talk! Email us at: berry-smart@mit.edu. 

Resources
===============================================================================
1. DHT library: https://github.com/RobTillaart/Arduino/tree/master/libraries/DHTstable
2. ESP32 datasheet: https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf

<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js" charset="utf-8"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
